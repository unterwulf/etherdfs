
                     *** ETHERDFS (ETHERNET) PROTOCOL ***

The ethernet communication between the client and the server is very simple:
for every INT 2F query, the client (etherdfs) sends a single ethernet frame to
the server, using the following format:

DOEEpppVSDLxxx

where:

offs|field| description
----+-----+-------------------------------------------------------------------
 0  | D   | destination MAC address
 6  | O   | origin (source) MAC address
 12 | EE  | EtherType value (0xEDF5)
 14 | ppp | padding: 42 bytes of garbage space. used to make sure every frame
    |     | respects the minimum ethernet payload length of 46 bytes. could
    |     | also be used in the future to fill in fake IP/UDP headers for
    |     | router traversal and such.
 56 | V   | single byte with the value of the etherdfs protocol version
 57 | S   | a single byte with a "sequence" value. Each query is supposed to
    |     | use a different sequence, to avoid the client getting confused if
    |     | it receives an answer relating to a different query than it
    |     | expects.
 58 | D   | a single byte representing the numeric value of the destination
    |     | (server-side) drive (A=0, B=1, C=2, etc).
 59 | L   | the AL value of the original INT 2F query, used by the server to
    |     | identify the exact "subfunction" that is being called.
 60 | xxx | a variable-length payload of the request, it highly depends on the
    |     | type subfunction being called.

For each request sent, the client expects to receive exactly one answer. The
client might (and is encouraged to) repeat the query if no valid answer came
back in a reasonable period of time (several milliseconds at least).

An answer has the following format:

DOEEpppVSAAxx

where:
 DOEEpppVS = same as in query (but with D and O reversed)
 AA = the 16-bit value of the AX register (0 for success).

Note: All numeric values are transmitted in the native x86 format (that is,
      "little endian"), with the obvious exception of the EtherType which
      must be transmitted in network byte order (big endian).

==============================================================================
RMDIR (0x01), MKDIR (0x03) and CHDIR (0x05)

Request: SSS...

SSS... = Variable length, contains the full path of the directory to create,
         remove or verify existence (like "\THIS\DIR").

Answer: -

Note: The returned value of AX is 0 on success.
==============================================================================
READFILE (0x08)

Request: OOOOSSLL

OOOO = offset of the file (where the read must start), 32-bits
SS   = starting sector of the open file (ie. its 16-bit identifier)
LL   = length of data to read

Answer: DDD...

DDD... = binary data of the read file

Note: AX is set to non-zero on error. Be warned that although LL can be set
      as high as 65535, the unerlying Ethernet network is unlikely to be able
      to accomodate such amounts of data.
==============================================================================
WRITEFILE (0x09)

Request: OOOOSSDDD...

OOOO = offset of the file (where the read must start), 32-bits
SS   = starting sector of the open file (ie. its 16-bit identifier)
DDD... = binary data that has to be written (variable lenght)

Answer: LL

LL = amounts of data (in bytes) actually written.

Note: AX is set to non-zero on error.
==============================================================================
DISKSPACE (0x0C)

Request: -

Answer: BBCCDD
  BB = BX value
  CC = CX value
  DD = DX value

Note: The AX value is already handled in the protocol's header, no need to
      transmit it a second time here.
==============================================================================
GETATTR (0x0F)

Request: fff...
  fff... = path/file name

Answer: ttddssssA
  tt = time of file (word)
  dd = date of file (word)
  ssss = file size (dword)
  A = single byte with the attributes of the file
==============================================================================
DELETE (0x13)

Request: fff...
  fff... = path/file name (may contain wildcards)

Answer: - (AX = 0 on success)
==============================================================================
OPEN (0x16) and CREATE (0x17)

Request: fff...
  fff... = path/file name

Answer: AfffffffffffttddssssCC (22 bytes)
  A = single byte with the attributes of the file
  fff... = filename in FCB format (always 11 bytes, "FILE0000TXT")
  tt = time of file (word)
  dd = date of file (word)
  ssss = file size (dword)
  CC = start cluster of the file (16 bits)

Note: Returns AX != 0 on error.
==============================================================================
FINDFIRST (0x1B) and FINDNEXT (0x1C)

Request: DDAffffffff...
  DD = a 16-bit value holding the directory count, set only for FINDNEXT
  A = single byte with attributes we look for
  ffff... = path/file mask (eg. X:\DIR\FILE????.???), variable length (up to
            the end of the ethernet frame)

Answer: Afffffffffffttddssss (20 bytes)
  A = single byte with the attributes of the file
  fff... = filename in FCB format (always 11 bytes, "FILE0000TXT")
  tt = time of file (word)
  dd = date of file (word)
  ssss = file size (dword)
==============================================================================
